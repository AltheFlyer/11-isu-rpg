import utils.AnimatedSprite;

import java.awt.Graphics;

/**
 * [JointMap.java]
 * The grid of PlayerTiles and EnemyTiles that the battle is situated on
 * @version 1.0
 * @author Kevin Liu
 * @since May 24, 2019
 */
public class JointMap {
    //the tile array that everything is on (x and y)
    private Tile[][] tileArray = new Tile[6][3];

    /**
     * Constructor for creating the JointMap
     * fills the left 3x3 side with PlayerTiles, fills the right 3x3 side with EnemyTiles
     */
    JointMap() {
        for (int j = 0; j < 3; j++) {
            for (int i = 0; i < 3; i++) {
                tileArray[i][j] = new PlayerTile(323 + i * 121, 108 + j * 121, i, j);
            }
            for (int i = 3; i < 6; i++) {
                tileArray[i][j] = new EnemyTile(323 + i * 121, 108 + j * 121, i, j);
            }
        }
    }

    /**
     * [draw]
     * runs through the entire map and will draw each tile and corresponding health bars on those tiles
     * @param g the graphics used to draw with
     */
    public void draw(Graphics g) {
        for (int j = 0; j < 3; j++) {
            for (int i = 0; i < 6; i++) {
                tileArray[i][j].draw(g);
                tileArray[i][j].drawHealthbar(g);
                tileArray[i][j].drawEnergybar(g);
            }
        }
    }

    /**
     * [target]
     * used to target a tile and either damage or heal the tile
     * @param i the x grid position of the tile to affect
     * @param j the y position of the tile to affect
     * @param damage the amount of damage or healing done
     */
    public void target(int i, int j, double damage) {
        if (damage < 0) {
            tileArray[i][j].healTile(-damage);
        } else {
            tileArray[i][j].damageTile(damage);
        }
    }

    /**
     * [inflictStatus]
     * Inflicts a status effect onto the entity at the specified tile, if possible (tile exists and contains an entity).
     * Make sure that the status was generated by a .spread() if generated from a pre-fab effect, OR that the status was
     * just created.
     * @param x the x grid position of the tile to affect
     * @param y the y position of the tile to affect
     * @param status the status effect to inflict
     */
    public void inflictStatus(int x, int y, StatusEffect status) {
        //Safety first
        if (tileExists(x, y)) {
            tileArray[x][y].inflictStatus(this, status);
        }
    }

    /**
     * [animateAttack]
     * will call a tile to animate an attack centered on that tile
     * @param g the graphics used to draw with
     * @param animation the animation to be drawn on the tile
     * @param i the x grid position of the tile to affect
     * @param j the y grid position of the tile to affect
     */
    public void animateAttack(Graphics g, AnimatedSprite animation, int i, int j){
        tileArray[i][j].animateAttack(g, animation);
    }

    /**
     * [addEntity]
     * adds an entity onto the jointMap
     * @param i the x coordinate of the supposed tile
     * @param j the y coordinate of the supposed tile
     * @param entity the entity that is to be added onto the jointMap
     */
    public void addEntity(int i, int j, Entity entity) {
        if (isTileFriendly(i,j)){
            ((PlayerTile)tileArray[i][j]).setPlayer((Player)entity);
        } else {
            ((EnemyTile)tileArray[i][j]).setEnemy((Enemy)entity);
        }
    }

    public Enemy getEnemy(int x, int y){
        return ((EnemyTile)tileArray[x][y]).getEnemy();
    }

    /**
     * [getEntity]
     * gets the entity in a certain location on the jointMap, used for abilities
     * @param x the x coordinate of the supposed tile
     * @param y the y coordinate of the supposed tile
     * @return entity, the entity that is currently situated on a tile on the jointMap
     */
    public Entity getEntity(int x, int y){
        return tileArray[x][y].getEntity();
    }

    /**
     * [tileExists]
     * gets whether the tile exists within the 6x3 tile grid
     * @param x the x coordinate of the supposed tile
     * @param y the y coordinate of the supposed tile
     * @return boolean, whether the tile is within the 6x3 tile array
     */
    public boolean tileExists(int x, int y) {
        return (x < 6) && (x >= 0) && (y < 3) && (y >= 0);
    }

    /**
     * [indicate]
     * indicates a certain tile, drawing it differently
     * @param x the x coordinate of the supposed tile
     * @param y the y coordinate of the supposed tile
     */
    public void indicate(int x, int y) {
        tileArray[x][y].indicate();
    }

    /**
     * [unIndicateAll]
     * unindicates all the tiles on the entire map, (done when an ability is deselcted)
     */
    public void unIndicateAll(){
        for (int j = 0; j < 3; j++) {
            for (int i = 0; i < 6; i++) {
                tileArray[i][j].unIndicate();
            }
        }
    }

    /**
     * [getIndication]
     * returns if a tile is indicated or not
     * @param x the x coordinate of the supposed tile
     * @param y the y coordinate of the supposed tile
     * @return boolean, true if the tile is indicated, false if it is not
     */
    public boolean getIndication(int x, int y){
        return tileArray[x][y].getIndication();
    }

    /**
     * [isEmpty]
     * gets whether the tile is empty (contains no entity) or not
     * @param x the y coordinate of the supposed tile
     * @param y the y coordinate of the supposed tile
     * @return boolean, whether the target tile is empty or not
     */
    public boolean isEmpty(int x, int y){
        return tileArray[x][y].isEmpty();
    }

    /**
     * [isTargetable]
     * sets a tile as targetable, (targetable tiles will glow when hovered and can be clicked on when an ability is selected to use that ability)
     * @param x the y coordinate of the supposed tile
     * @param y the y coordinate of the supposed tile
     */
    public void isTargetable(int x, int y){
        tileArray[x][y].isTargetable();
    }

    /**
     * [unTargetableAll]
     * unTargetables all the tiles on the entire map, (done when an ability is deselcted)
     */
    public void unTargetableAll(){
        for (int j = 0; j < 3; j++) {
            for (int i = 0; i < 6; i++) {
                tileArray[i][j].unTargetable();
            }
        }
    }

    /**
     * [getTargetable]
     * gets if a tile is targetable or not,
     * (targetable tiles will glow when hovered and can be clicked on when an ability is selected to use that ability)
     * @param x the x coordinate of the supposed tile
     * @param y the y coordinate of the supposed tile
     * @return boolean, true if the tile is targetable, false if it is not
     */
    public boolean getTargetable(int x, int y){
        return tileArray[x][y].getTargetable();
    }

    /**
     * [moveOnTile]
     * moves an entity to a different tile that exists, on the same side (player/enemy) and is empty
     * @param x the x coord of the tile that the entity is currently at
     * @param y the y coord of the tile that the entity is currently at
     * @param xMove the x coord of the tile that the entity is moving to
     * @param yMove the y coord of the tile that the entity is moving to
     */
    public void moveOnTile(int x, int y, int xMove, int yMove) {
        if (tileExists(xMove, yMove) && isEmpty(xMove, yMove)) {
            if (isTileFriendly(x, y) && tileExists(xMove, yMove) && isTileFriendly(xMove, yMove)) {
                ((PlayerTile) tileArray[x][y]).getPlayer().setXGrid(xMove);
                ((PlayerTile) tileArray[x][y]).getPlayer().setYGrid(yMove);
                ((PlayerTile) tileArray[xMove][yMove]).setPlayer(((PlayerTile) tileArray[x][y]).getPlayer());
                ((PlayerTile) tileArray[x][y]).nullPlayer();
            } else if (!isTileFriendly(x, y) && tileExists(xMove, yMove)&& !isTileFriendly(xMove, yMove)) {
                ((EnemyTile) tileArray[x][y]).getEnemy().setXGrid(xMove);
                ((EnemyTile) tileArray[x][y]).getEnemy().setYGrid(yMove);
                ((EnemyTile) tileArray[xMove][yMove]).setEnemy(((EnemyTile) tileArray[x][y]).getEnemy());
                ((EnemyTile) tileArray[x][y]).nullEnemy();
            }
        }
    }

    /**
     * [isTileFriendly]
     * Gets whether the tile is friendly or not. Generally true for all x in {0, 1, 2} and false for all
     * x in {3, 4, 5} in a standard pre-fab grid
     * @param x
     * @param y
     * @return boolean, whether the tile is friendly or not
     */
    public boolean isTileFriendly(int x, int y){
        return tileArray[x][y].isTileFriendly();
    }

    /**
     * [drawIcons]
     * goes through all the enemies and draws their icons (intents)
     * @param g the graphics used to draw with
     * @param mouseX the x coord of the mouseLocation (pixels)
     * @param mouseY the y coord of the mouseLocation (pixels)
     */
    public void drawIcons(Graphics g, int mouseX, int mouseY) {
        //Icons first
        for (int j = 0; j < 3; j++) {
            for (int i = 0; i < 6; i++) {
                tileArray[i][j].drawIcons(g);
            }
        }

        //Text boxes second
        for (int j = 0; j < 3; j++) {
            for (int i = 0; i < 6; i++) {
                tileArray[i][j].drawIconText(g, mouseX, mouseY);
            }
        }
    }

    /**
     * [runEnemyTurnActions]
     * runs an enemy's actions to preserve encapsulation standards (for now)
     * @param enemy the enemy that is currently acting out its turn
     */
    public void runEnemyActions(Enemy enemy) {

        this.unIndicateAll();
        this.unTargetableAll();

        enemy.act(this);

        //Reset for the next enemy
        this.unIndicateAll();
        this.unTargetableAll();
    }

    /**
     * [generateEnemyDecisions]
     * generate's an enemy's intents to preserve encapsulation standards
     * @param enemy the enemy that is currently generating intents
     */
    public void generateEnemyDecisions(Enemy enemy){
        //Generate intent
        enemy.decide(this);
    }

    /**
     * [procPlayerStatus]
     * will go through all PlayerTiles and proc any status effects affecting any players
     */
    public void procPlayerStatus() {
        for (int j = 0; j < 3; j++) {
            //player side only
            for (int i = 0; i < 3; i++) {
                Tile tile = tileArray[i][j];
                if (!tile.isEmpty()) {
                    tile.procStatus(this);
                    if (tile.getEntity().getHealth() <= 0) {
                        tile.nullEntity();
                    }
                }
            }
        }
    }

    /**
     * [procEnemyStatus]
     * will go through all EnemyTiles and proc any status effects affecting any enemies
     */
    public void procEnemyStatus() {
        for (int j = 0; j < 3; j++) {
            //Enemy side only
            for (int i = 3; i < 6; i++) {
                Tile tile = tileArray[i][j];
                if (!tile.isEmpty()) {
                    tile.procStatus(this);
                    if (tile.getEntity().getHealth() <= 0) {
                        tile.nullEntity();
                    }
                }
            }
        }
    }

    /**
     * [checkAlive]
     * goes through all the tiles to check if the players/enemies are above 0 health, if they are not
     * they are nulled
     */
    public void checkAlive() {
        for (int j = 0; j < 3; j++) {
            for (int i = 0; i < 6; i++) {
                if (!tileArray[i][j].isEmpty()) {
                    if (tileArray[i][j].getEntity().getHealth() <= 0) {
                        tileArray[i][j].nullEntity();
                    }
                }
            }
        }
    }

}